import {siteUrl} from "@/constants"
import {addComment, loadComments} from "@/firebase/comments"
import sendEmail from "@/nodemailer/sendEmail"
import {getAuth} from "firebase-admin/auth"
import CommentApp from "./CommentApp"

export default function ArticleComments({
  slug,
  title,
}: {
  slug: string
  title: string
}) {
  async function saveComment(formData: FormData) {
    "use server"
    const comment = formData.get("comment")?.toString().trim() ?? ""
    const userId = formData.get("userId")?.toString().trim() ?? ""
    if (!comment || !userId) {
      throw Error(`400: Invalid payload ${JSON.stringify({comment, userId})}`)
    }
    /* getUser throws an error if there's no match for the user ID */
    const {displayName, email, photoURL, uid} = await getAuth().getUser(userId)
    await addComment(slug, {
      text: comment,
      user: {displayName, email, photoURL, uid},
    })
    /* we need to await the call to send the email, but it
    doesn't matter if it resolves or rejects since we've already
    added the new comment and need to return the updated list */
    const [commentsRes] = await Promise.allSettled([
      loadComments(slug),
      sendEmail({
        html: `
          <p>${comment}</p>
          <p>${siteUrl}/posts/${slug}</p>
          <p>${email}</p>
          <p>ðŸš¨ðŸš¨ This is an autogenerated email from an unmonitored mailbox, please do not reply ðŸš¨ðŸš¨</p>
        `,
        subject: `${displayName} commented on ${title}`,
      }),
    ])
    if (commentsRes.status === "rejected") {
      throw Error("500: unable to load comments")
    }
    return commentsRes.value
  }
  return <CommentApp {...{saveComment, slug}} />
}
